함수
- 일련의 처리를 하나로 모아 언제든 호출할 수 있도록 만들어 놓은것
- 기능 
- 함수 = 매서드

1. 함수 선언문으로 함수 정의하기

	function 함수명(매개변수,...) {
		// 실행코드 정의..
		return 반환값;
	}
	
	
	function abc() {
	};
	console.dir(abc);
	


1. 함수 선언문으로 함수 정의하기

	function 함수명 (매개변수, ..... ) {
		// 실행 코드 ...

		return 반환값;
	}

	2x + 1 = y

	function abc(x) {
		y = 2x + y;
		retur y;
	}

	x: 매개변수


	function add(num1, num2) {
		var result = num1 + num2;
		return result;
	}
	
	=>
	
	add : 변수 - 함수 객체의 주소값 
	함수도 변수이다. 함수명 add는 함수객체의 주소값
	
	add2 = add;
	add2(20,30); -> 50
	
	console.dir(add);
	
	객체간의 상속 ( 이미 만들어진 객체끼리 상속관계로 연결시킴 )
	상속 : 
	  [[Prototype]] :프로토타입 체인 - 상속 관계 링크
	                : __proto__ 속성을 통해서 접근
					

	function add(num1, num2) {
		var result = num1 + num2;
		return result;
	}

	==>

	var add = function (num1, num2) {
		var result = num1 + num2;
		return result;
	}
	

2. 함수 호출			
3. 함수의 실행흐름
4. 함수 선언문의 끌어올림

   함수객체(실행X) -> 번역(평가) -> 실행가능객체(EC - Execution Context) -> 실행

	var num0 = 5;   //전역변수

	function outer() {
		var num1 = 10; //지역변수

		function inner() {
			var num2 = 20;
			var result = num0 + num1 + num2;
			return result;
		}
		var resullt = inner();
		console.log(result);
	}
	
	=>
	
	global EC {
		변수레코드 - window 의 하위 속성으로 변수가 정의
		window.num0 = 5;
		외부변수 레코드 참조 : global EC 레코드 주소 : window
		this바인딩 : window객체의 주소값
	}
	outer EC {
		변수 레코드 객체: {
			num1: 10
		}
		외부변수 레코드 참조 : num0 = 5
		
	}
	inner EC {
		변수 레코드 객체 {
			num2: 20,
			result: 35
		}
		외부 변수 레코드 참조:
	}
	외부 변수 레코드 참조: outer EC 변수 레코드 주소
	
	유효범위 체인(Scope)
	
	------------------------------------------------
	const person = {
		name: '최혜진',
		age: 40,
		showInfo: function() {
			console.log(this);
		}
	}
	undefined
	person.showInfo();
	VM5766:5 {name: '최혜진', age: 40, showInfo: ƒ}
	undefined
	const showInfo = pserson.showInfo;
	VM5847:1 Uncaught ReferenceError: pserson is not defined
		at <anonymous>:1:18
	(익명) @ VM5847:1
	const showInfo = person.showInfo;
	undefined
	showInfo();	
	--------------------------------------------------
5. 값으로서의 함수
	함수(X), 함수객체(O) - 값이 있음, 변수에 대입 가능
	일등 함수 : 변수와 함수를 동등하게 취급한다, 함수 == 값
	
	function outer() {
		console.log('outer 호출');
		inner();
		
		function inner() {
			console.log('inner 호출');
		}
	}
	outer();
	
	
	function outer() {
		function inner() { //지역변수 inner 에 함수객체의 주소 대입
		}
	}
	
	
	함수명는 변수, 함수는 객체. 	
	
	일등 함수 : 변수와 함수를 동등하게 취급한다, 함수 == 값	
	 1) 매개변수로 함수객체를 사용
	 2) 반환값으로 함수객체를 사용(클로저..)
	 -> 함수형 프로그래밍이 가능
	 
	ex) 
	----------------------------
	function outer(callback) {
		var num = 3;
		callback(num);
	}
	function inner(n) {
		console.log(`숫자 : ${n}`);
	}
	outer(inner);
	----------------------------

	-> 숫자 : 3	
	
	----------------------------
	function outer(callback) {
		var num = 3;
		callback(num);
	}
	outer(function (n) {
    console.log(n);
	----------------------------

	----------------------------
	var fruits = ["apple", "Orange", "Mango"];
	undefined
	fruits.forEach(function(fruit) {
		console.log(fruit);
	});
	
	apple
	Orange
	Mango

});
	
6. 참조에 의한 호출과 값에 의한 호출

변수의 유효범위
1. 전역 유효 범위와 지역 유효범위
    -> 함수지역
	-> 유효범위 체인(Scope)
	
2. 변수의 충돌
	같은 이름이면 지역변수 우선함
	
3. 함수 안에서 변수 선언과 변수 끌어올림( hoisting 호이스팅)

4. 함수 안에서 변수 선언 생략
5. 블록 유효 범위 : let과 const

	var: 함수 지역이 유효범위
	let, const -> { ... } 중괄호 안에서만 유효함
	let : 변수 - 값 변경이 가능
	const: 상수 - 값변경 불가능
	
	-> 변수는 기본적으로 const로 정의, 변경이 필요한 경우만 let으로 사용
	
	
6. 함수 리터럴로 함수 정의하기
	const 변수명 = 함수객체;
	
	console.log(add);
	//add(100, 200);     // 여기선 에러남.. 
	
	var add = function(num1, num2) {
		var result = num1 + num2;
		return result;
	};
	add(100, 200);  // 요렇게 써야
	
	this 바인딍 : 호출한 객체의 주소값
	∴ this : 호출할때 결정됨 
	
	
7. 객체의 메서드
8. 즉시 실행 함수
	- 함수 정의와 동시에 호출
	
	(function(매개변수정의, ...) {
	})(인자...);
	
	let result = (function(num1,num2) {
		const ret = num1 + num2;
		return ret;
	})(10,20);
	

9. 가변길이 인수 목록(Arguments 객체)
	arguments - 인자: 매개변수로 사용된 값
	parameter - 인수
	
	전개 연산자, 나머지 연산자: ...
	
	function sum(...params) {
		console.log(params);
	}

	function func1(a,b) {
		b = b || 10;     //  <- 기본값 세팅 방법으로 사용:과거방식
		console.log('a', a, 'b', b);
	}
	=>
	function add(a,b = 10) {  // 기본값 세팅 방법2 : 오즘방식
    console.log('a', a, 'b', b);
}

생성자	

함수객체 -> 다른 객체 생산

new 연산자: 메모리에 공간을 생성하는 연산자

생성자 함수명
  첫 시작 문자 대문자

객체가 생성되는 과정
1. 함수가 객체에 정의된 prototype 객체의 상속
2. this값을 상속받은 객체로 변경함으로써 초기화


function Person () {
    this.name = '최혜진';
    this.age = 40;
}
const p1 = new Person();

참고) 객체간의 상속
	프로토타입 체인 연결
	[[Prototype]]: 프로토타입 체인

	__proto__ 

	const objA = { a: 10, b: 20};
	const objB = { c: 30, d: 40};
	objA.__proto__ = objB; //  <-  


	---------------------------
	function Person () {
		this.name = '최혜진';
		this.age = 40;
	}
	---------------------------
	const p1 = new Person(); 

	<-  상속하면서 생성하는 방법

	const p1 = {};
	p1.__proto__ = Person.prototype;
	Person.call(p1);  <- 초기화
	
	<-   생성하여 상속연결하고 call로 this의 값을 바꿔줌
	
	다시
	-------------------------------------
	function Person () {
		this.name = '최혜진';
		this.age = 40;
	}

	const p1 = {};
	p1.__proto__ = Person.prototype;
	p1;
	 => Person {}
	Person.prototype.constructor.call(p1);  // ∵ Person.prototype.constructor === Person 초기화
	p1;
	 => Person {name: '최혜진', age: 40}

	-------------------------------------
	function Person(name, age) {
	this.name = name;
	this.age = age;
	}
	const p1 = new Person("최혜진", 20);
	const p2 = new Person("최혜진2", 40);
	p1;
	=>Person {name: '최혜진', age: 20}
	p2;
	=>Person {name: '최혜진2', age: 40}
	p1.showInfo();
	=> 최혜진 20
	p2.showInfo();
	=> 최혜진2 40



모든함수
	function Function() {
	}
	
	모든함수는 apply, call