리액트의 이해

- 리액트는 프레임워크가 아닌 V(View)만 신경쓰고 있는 라이브러리
- 그러나 다양한 라이브러리를 조합해서 사용가능
DOM
DOMTree
-> DOM의 조작 가하면 -> DOMTree -> CSS 관계설정 -> 배치 과정 다시 거치므로 느려지는 거 해결위해 페이스북이 만듬

가상의 DOM 복사본을 메모리에 가지고 있다가 얕은 비교하여 컨텐츠 바뀌면 그 컴포넌트 부분 다 비우고 복사본으로 바꿔버림 
DOM을 새로 구성하는데 너무 오래 걸림 (React.js 비슷한 Vue.js 도 있음, 훨씬 쉽지만 라이브러리는 React가 많음)

트랜스파일러
JSX -> JS 

-> 개발서버 (node.js : javascript 런타임, 구글이 만듬 - V8) 설치
  (1)node.js v20.12.01 다운, 설치 ( 필요한툴설치 옵션 체크 안함 )
  
  c:\> node -v
  node : 자바스크립트 코드 실행 명령 
  c:\> node js파일
  
	npm: node package manager 
	- 의존성 관리(프로젝트에서 필요한 라이브러리..)
	- 빌드 : 개발소스를 서비스(배포) 가능 상태로 변경해 줌(리액트문법 소스 -> js)
	- 테스트

	install : 설치
	npm install 패키지명 ( npm i 패키지명 ) -> 설치, 현재 프로젝트의 node_modules 폴더에 설치된다
	npm uninstall 패키지명 -> 삭제

	npm --global install 패키지명 -> 모든 프로젝트가 공유할 수 있도록 설치 npmjs.org 사이트
	npm --g install 패키지명
	init : 프로젝트 생성 명령

	ex) npmjs.org 사이트에서 npmjs-modal 검색하면... 

	yarn - npm과 동일역할(메타 개발, 설치속도 빠른 장점, UI깔끔함)
	create : 프로젝트 생성 명령
	add 패키지명

	(2)yarn설치
	npm i -g yarn
	yarn --version
	
	(3) 프로젝트 react-app 생성
	D:\hjchoi\2.실무프로젝트-P1> yarn create react-app hello  
	cd helllo
	D:\hjchoi\2.실무프로젝트-P1\helllo> yarn start  -> 허용버튼
	^C
	
	VSCODE open Folder -> hello
	
	npm i ->
	.gitignore ..> /node_modules 는 배제됨..
	버전체계 ex) ^5.14.1 -> 메이저버전.마이너버전.패치번호 
	    (메이저버전: 하위버전과 호환되지 않는 큰변화 / 마이너: 기능추가,수정 / 패치: 오류수정, 보완)
	
	yarn start
	yarn build
	yarn test
	yarn eject
	
	참고)
	npm으로 스크립트명령어 실행은 
	npm run start
	npm run build
	
	VSCODE 확장 프로그램
	1. ESLint : javascript 문법 자동체크
	2. Reactjs Code Snippets : 리액트 코드(템플릿) 자동완성
	3. prettier-Code formatter : 코드스타일을 자동으로 정리하는 도구
	
	.prettierrc 파일추가
		{
		"singleQuote": true,
		"useTabs": false,
		"tabWidth": 2,
		"semi": true,
		"trailingComma":"all"
		}
		
	-> F1 키 -> format Document -> prettier... 
	= file - preferenct -> settings -> 검색어 format -> Format On Save 체크 
	
	Terminal -> new terminal -> Command Prompt -> yarn start
	
	public\index.html
	src\index.js
	
	<React.StrictMode></React.StrictMode>  .. 이런거 JSX 문법
	
웹팩 라이브러리

1. 초기 렌더링
- render() 함수    <- src/index.js

	root.render(
	  <React.StrictMode>
		<App />
	  </React.StrictMode>
	);

2. 조화과정
1)  Virtual DOM
- Virtual DOM을 이용하면 실제 DOM에 접근하여 조작하는 대신, 이를 추상화한 자바스크립트 객체를 구성하여 사용
- 실제 DOM의 가벼운 사본과 비슷

2) 리액트에서 데이터가 변하여 웹브라우저 실제 DOM을 업데이트 하는 절차 
- 데이터를 업데이트하면 전체 UI를 Virtual DOM에 리렌더링 합니다.
- 이전 Virtual DOM에 있던 내용과 전체 내용을 비교합니다.
- 바뀐 부분만 실제 DOM에 적용합니다.

작업 환경 설정 
1. Node.js 설치 
2. yarn 설치
1) 맥 
	- npm install --global yarn 
	- npm i -g yarn 
	
2) 윈도우즈 
	- yarn 공식 사이트에서 다운로드
	
3. 에디터 설치(vscode)
	- 확장 프로그램 설치
	1) ESLint : 자바스크립트 문법 및 코드 스타일을 검사해주는 도구 
	2) Reactjs Code Snippets : 리액트 사용시 단축 단어를 사용하여 코드 자동완성할 수 있는 도구(제작자가 charalmpos karypidis 인 것 선택)
	3) Prettier-Code formatter : 코드 스타일을 자동으로 정리해 주는 도구
	
	
4. create-react-app으로 프로젝트 생성하기

- yarn create react-app hello

- yarn을 사용하지 않는 경우 
(npm init react-app 프로젝트 이름)



JSX
1. 코드 이해하기 

	src/App.js

	참고)
	- 직접 작성한 파일, 자원을 로드 
	import ... from "./..." -> 동일 경로  
	import ... from "../..." -> 상위 경로 
	import { Fragment } from 'react' -> node_modules/react/index.js  (/index.js 생략된 표현)
	import App from './App'; -> ./App.js 의 .js 생략됨

	=> 웹팩(WebPack) 이 나중에 이런 import된 컴포넌트들을 index.html과 css와 js로 합쳐줌 
	   src/index.js를 시작으로 필요한 파일을 다 불러와서 번들링

	export: 모듈 내보내기
	export default 변수명; -> import 변수명(변경가능) from 파일명 으로 가져옴  모듈1개 내보내기
	export  변수명; -> 모듈 여러개 내보내기 import 변수명(변경불가) from 파일명  으로 가져옴
                    -> as 로 변수명 변경 가능
	document.createElement("div");
	

2. JSX란?
- JSX는 자바스크립트의 확장 문법이며 XML과 매우 비슷하게 생김
- 이런 형식으로 작성한 코드는 브라우저에서 실행되기 전에 코드가 번들링되는 과정에서 바벨을 사용하여 일반 자바스크립트 형태의 코드로 변환됩니다.

JSX 문법 
1. 감싸인 요소
- 반드시 하나의 요소에 의하여 감싸여 있어야 합니다. => 컴포넌트 단위로 교체 가능하므로 
- Virtual DOM에서 컴포넌트의 변화를 감지해 낼 때 효율적으로 비교할 수 있도록 컴포넌트 내부는 하나의 DOM 트리 구조로 이루어져야 한다는 규칙 
- Fragment : 태그로 랜더링 안되는 JSX용 태그, 하나의 요소로 감싸기 위해 사용됨
  import {Fragment} from 'react'; 
  <Fragment></Fragment> 길어서 줄이면  <></>

	App.js
	
	const App = () => {
		const name = "React";
		return (
			<>
			</>
		);
	};
	export default App;

참고) 부분화면
      함수형 컴포넌트( 화살표함수 권장 )
	  클래스형 컴포넌트

참고) 비구조화 할당 

	const MyComponent = (props) => {
	  const {name, num} = { props } ;   
	  return (
		<>
		  <div>안녕하세요, 제 이름은 {name} 입니다.</div>;
		  <div>좋아하는 숫자는 {num} 입니다.</div>;
		</>
	  );
	};


	const MyComponent = ({ name, num }) => {
	  console.log(typeof name, typeof num);
	  return (
		<>
		  <div>안녕하세요, 제 이름은 {name} 입니다.</div>;
		  <div>좋아하는 숫자는 {num} 입니다.</div>;
		</>
	  );
	};


2. 자바스크립트 표현 
  - 자바스크립트 표현식을 작성하려면 JSX 내부에서 코드를 { }로 감싸면 됩니다.

3. if문 대신 조건부 연산자(삼항조건식)
 
4. AND 연산자(&&)를 사용한 조건부 렌더링
	{name && name} 
	
5. undefined를 렌더링하지 않기

- 리액트 컴포넌트에서는 함수에서 undefined만 반환하여 렌더링하는 상황을 만들면 안됩니다(오류 발생함)
- 기본값 지정하여 오류 방지

6. 인라인 스타일링 
1) CSS는 객체 형태로 넣어 주어야 함 
	<div style={{ color: 'blue' }}>신나는 공부</div>

2) "-" 문자가 포함되는 이름이 있을땐 "-" 을 제거하고 카멜 표기법으로 작성 
	background-color 

	  const style = {
		backgroundColor: 'orange',  // <- background-color
		color: 'white',
		height: '100px',
	  };

	
7. class 대신 className 
	<div className="subject" style={style}>
8. 꼭 닫아야 하는 태그
	

9. 주석 - JSX 문법에서
- {/* ... */} 형식으로 작성 
- 시작태그를 여러 줄로 작성할 때는 그 내부에서 // ... 와 같은 형태로 작성할 수 있음 

	{/* 주석 ... */}

	<input
		// 주석 ...
		type="text"
	/>

VSCODE

	ESLint와 Prettier 적용하기
	1. ESLint 
	- 보기 > 문제를 클릭하여 확인 

	2. Prettier 
	- VS Code에서 F1을 누르고 format이라고 입력한 후 Enter를 누르면 자동 정리
	- 자동으로 코드 정리를 하려면 
	- 파일 -> 기본 설정 -> 설정 -> Format On Save 옵션 체크 : 저장시 자동 정리
	- 설정 파일 작성 
	.prettierrc

	{
		"singleQuote": true,
		"semi": true,
		"useTabs": false,
		"tabWidth": 2
	}

	hello> cd ..
	> yarn create react-app exam01
	.prettierrc 


컴포넌트
1. 클래스형 컴포넌트
	Component  상속 
	
	render() {
		reutrn (
			JSX 문법 컴포넌트 ...
		)	
	}
	
2. 함수형 컴포넌트 

첫 컴포넌트 생성
1. 모듈 내보내기(export)
2. 모듈 불러오기(import)

3. props

1) props는 properties를 줄인 표현으로 컴포넌트 속성을 설정할 때 사용하는 요소입니다.

2) props 값은 해당 컴포넌트를 불러와 사용하는 부모 컴포넌트에서 설정할 수 있습니다.
  - 객제동결상태, 삭제 불가, 속성추가 불가
  
	App.js
	
	import MyComponent from './components/MyComponent';

		const App = () => {
			return <MyComponent name="hjchoi2"/>
		};
	export default App;
  
	MyComponents.js
	-----------------------------------------------------------
	const MyComponent = (props) => {
		console.log(Object.getOwnPropertyDescriptors(props));
		//props.name = "최혜진";  <- 에러
	  return <div>안녕하세요, 제 이름은 {props.name} 입니다.</div>;
	};
	-----------------------------------------------------------
	const MyComponent = (props) => {
		const {name} = props;
		return <div>안녕하세요, 제 이름은 {name} 입니다.</div>;
	};
	-----------------------------------------------------------
	const MyComponent = ({name}) => {
		return <div>안녕하세요, 제 이름은 {name} 입니다.</div>;
	};
	-----------------------------------------------------------
	위 세개다 동일함
	
3) props 기본값 설정: defaultProps
	MyComponent.defaultProps = {name: '기본이름'};
	참고) || => 기본값 설정
	let num = 0;
	num = num || 10  // 10대체
	-> num = 10

	?? -> undefined, null만 대체  
	let num = 0;
	num = num ?? 10    //   0 도 의미있는 초기값으로 쓰여야 한다면 
	-> num = 0
	

	App.js
	-----------------------------------------------------------
	import MyComponent from './components/MyComponent';

	const App = () => {
	  //  return <MyComponent name="hjchoi2" num = {5}/>
	  return <MyComponent name={500} num={5} />;
	};
	export default App;

	MyComponents.js
	-----------------------------------------------------------
	import PropTypes from 'prop-types';

	const MyComponent = ({ name, num }) => {
	  console.log(typeof name, typeof num);
	  return (
		<>
		  <div>안녕하세요, 제 이름은 {name} 입니다.</div>;
		  <div>좋아하는 숫자는 {num} 입니다.</div>;
		</>
	  );
	};
	MyComponent.defaultProps = { name: '기본이름' };
	MyComponent.propTypes = {
	  name: PropTypes.string,  // 타입이 안맞으면 개발자도구의 콘솔에 경고 표시만..
	  num: PropTypes.number.isRequired,
	};
	export default MyComponent;	
	-----------------------------------------------------------
	
4) children

	const App = () => {
	  //  return <MyComponent name="hjchoi2" num = {5}/>
	  return (
		<MyComponent name="hjchoir" num={5}>
		  <h1>반갑습니다!</h1>
		</MyComponent>
	  );
	};

	const MyComponent = ({ name, num, children }) => {
	  console.log(typeof name, typeof num);
	  return (
		<>
		  <div>안녕하세요, 제 이름은 {name} 입니다.</div>
		  <div>좋아하는 숫자는 {num} 입니다.</div>
		  {children}
		</>
	  );
	};



5) propTypes를 통한 props 검증 => 경고만 뜬다.
	- 자료형 한정 prop-types
	MyComponent.propTypes = {
		name: PropTypes.string,
	}

3. 클래스형 컴포넌트에서 props 사용하기
	- 클래스형 컴포넌트에서 props를 사용할 때는 render 함수에서 this.props를 조회하면 됩니다.
	- defaultProps와 propTypes는 똑같은 방식으로 설정할 수 있습니다.

		import { Component } from 'react';

		class MyComponent extends Component {
		  render() {
			console.log(this.props);

			const {name, num, children} = this.props;
			return (
			  <>
				<div>안녕하세요 제이름은 {name} 입니다.</div>
				<div>좋아하는 숫자는 {num} 입니다.</div>
				{children}
			  </>
			);
		  }
		}

		export default MyComponent;

4/3

	리액트의 state 와 useState 이해하기
	https://velog.io/@ryh0629/React-%EB%B3%80%EC%88%98-state-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0
	https://funveloper.tistory.com/192
		
		
4. state

변수 state는 컴포넌트에서 데이터를 담기 위해 사용되는 변수이다.
state는 변경되면 자동으로 재렌더링 되기 때문에 state 사용.

	참고)컴포넌트 재랜더링 기준(랜더링 :함수형 컴포넌트는 다시 호출, 클래스형 컴포넌트는 render 함수 다시 호출)
		1) props값이 변경
		2) state값이 변경
		3) 부모 컴포넌트가 렌더링되면

	1)  state는 컴포넌트 내부에서 바뀔 수 있는 값을 의미합니다.

		--------App.js--------------------------------------------
		import Profile from './components/Profile';
		const App = () => {
		  return <Profile />;
		};
		export default App;
		--------Profile.js------------------------------------------
		import { useState } from 'react';
		const Profile = () => {
		  const [data, setData] = useState({
			name: 'hjchoi',
			age: 40,
		  });
		  const changeProfile = () => {
			//주소가 달라져야 바뀐것으로 인식함- 이건 바뀐지 탐지 안됨
			//data.name = 'hjchoiA';
			//data.age = 30;
			//setData(data);

			//주소가 달라져야 바뀐것으로 인식함, 새로운객체로
			setData({ name: 'hjchoiA', age: 30 });
			// 전개연산자로 써도 됨
			setData({ ...data, name: 'hjchoiA' });
		  };

		  const { name, age } = data;
		  return (
			<>
			  <h1>{name}</h1>
			  <h1>{age}</h1>
			  <button type="button" onClick={changeProfile}>
				변경
			  </button>
			</>
		  );		
		----------------------------------------------------

		setData((state) => {
		  console.log('이전상태값: ', state);
		  //return { ...data, name: 'hjchoiA' }; //아래와 동일
		  return { ...state, name: 'hjchoiA' };  
		});
		----------------------------------------------------

	2)  props는 컴포넌트가 사용되는 과정에서 부모 컴포넌트가 설정하는 값이며, 컴포넌트 자신은 해당 props를 읽기 전용으로 사용 (동결상태이므로)
		함수형 컴포넌트에서 useState()
		배열값 -> 0 : 상태값, 1 : 상태값 변경 함수 -> 다시 랜더링
		
		
	3) this.setState를 사용하여 state에 새로운 값을 넣을 수 있습니다.
	4) state 객체 안에 여러 값이 있을 때
	5) state를 constructor에서 꺼내기
	6) this.setState에 객체 대신 함수 인자 전달하기

	this.setState((prevState, props) => {
		return {
			// 업데이트하고 싶은 내용
		}
	});

	5. state를 사용할 때 주의사항
	1) 클래스 컴포넌트든 함수 컴포넌트든 state값을 바꾸어야 할 때는 setState 혹은 useState를 통해 전달받은 세터 함수를 사용해야 합니다.
	2) 배열이나 객체 사본을 만들고 그 사본에 값을 업데이트한 후, 그 사본의 상태를 setState 혹은 세터 함수를 통해 업데이트합니다.


이벤트처리

VSCODE Terminal에서
D:\hjchoi\2.실무프로젝트-P1> yarn create react-app exam02
open foler exam02
.prettierrc 파일만들기

컴포넌트 파일, 컴포넌트명은 첫글자 대문자

4/4

onclick -> onClick 리액트는 카멜포기로

onClick 마우스 좌측키 클릭
onContextMenu -> 마우스 우측키 클릭

event
	target
	currentTarget === this 

onsubmit 
onSubmit={..}  : react는 단일페이지 서비스 .. form action= 다른 페이지로 가지 못하도록해야함

  const onSubmit = (e) => {
    e.preventDefault();
    console.log(userId, userPw);
  };
  
  <form onSubmit={onSubmit}>
  
	const key = "name";
	const person = {
		[key] : 'hjchoi',
		age: 40
	};
	
	person;
	{name: 'hjchoi', age: 40}
	
	const person2 = {...person, name: 'hjchoir'};

exam02 \ JoinForm.js

이벤트 핸들링
1. 리액트의 이벤트 시스템
- 웹 브라우저의 HTML 이벤트와 인터페이스가 동일하기 때문에 사용법이 비슷

2. 이벤트를 사용할 때 주의사항
1) 이벤트 이름은 카멜표기법으로 작성
2) 이벤트에 실행할 자바스크립트 코드를 전달하는 것이 아니라, 함수 형태의 값을 전달
3) DOM 요소에만 이벤트를 설정할 수 있음
	div, input, ...

3. 이벤트 핸들링 익히기
- onChange 이벤트 핸들링하기
1) state에 input 값 담기
2) 버튼을 누를 때 comment 값을 공백으로 설정
3)  이벤트에 실행할 자바스크립트 코드를 전달하는 것이 아니라, 함수 형태의 값을 전달합니다.
4) 화살표 함수 형태로 메서드를 정의
5) input 여러 개 다루기
	- event 객체를 활용하는 것, e.target.name 값을 사용
	
	
ref: DOM에 이름 달기

1. ref는 어떤 상황에서 사용해야 할까?
	SPA (Single Page Application) -> 그래서 id 쓰지 말기( 하나의 페이지로 서비스하므로 id가 겹칠까봐
	그래서 대신 ref 사용
	
	
1) DOM을 꼭 직접적으로 건드려야 할 때
	- 특정 input에 포커스 주기
	- 스크롤 박스 조작하기
	- Canvas 요소에 그림 그리기

2. ref 사용
	- 콜백 함수를 통한 ref 설정
	- ref를 달고자 하는 요소에 ref라는 콜백 함수를 props로 전달해 주면 됩니다.
	- 이 콜백 함수는 ref 값을 파라미터로 전달받습니다.
	- 함수 내부에서 파라미터로 받은 ref를 컴포넌트의 멤버 변수로 설정해 줍니다.
	
	1) createRef를 통한 ref 설정
		input = React.createRef();
		<input ref={this.input} />
	2) input에 ref 달기
		<input ref={(ref) => this.input=ref} ... />
	
	3) 컴포넌트에 ref 달기
		- 컴포넌트 내부에 있는 DOM을 컴포넌트 외부에서 사용할 때
		<MyComponent 
			ref={(ref) => {this.myComponent=ref}}
		/>
			
	4) useRef()
		- current 속성을 통해 접근
		- 컴포넌트에서 사용할 지역변수
		
4/5

컴포넌트 반복

컴포넌트 종류
	1)컨테이너 컴포넌트: 데이터 처리, 이벤트 처리, 여러 프리젠테이셔널 컴포넌트를 포함
	2)프리젠테이셔널 컴포넌트 : 보이는 화면 구성
모델 
	- 데이터 관련 로직


exam03 : AddTodo TodoList TodoContainer
	
테미널 -> 
yarn create react-app exam03  (exam03 폴더 미리 만들지 말고)

open folder -> exam03 후  exam03 폴더 안에서 터미널 열고
yarn add react-icons

yarn start 



1. 자바스크립트 배열의 map() 함수
	데이터 -> JSX 형태로 변환
	Array.prototype.map() : 배열 내의 모든 요소 각각에 대하여 주어진 함수를 호출한 결과를 모아 새로운 배열을 반환
	
2. 데이터 배열을 컴포넌트 배열로 변환하기
3. key
1)  key는 컴포넌트 배열을 렌더링했을 때 어떤 원소에 변동이 있었는지 알아내려고 사용
2) 유동적인 데이터를 다룰 때는 원소를 새로 생성할 수도, 제거할 수도, 수정할 수도 있습니다.
3)  key가 없을 때는 Virtual DOM을 비교하는 과정에서 리스트를 순차적으로 비교하면서 변화를 감지합니다. 
4) 하지만 key가 있다면 이 값을 사용하여 어떤 변화가 일어났는지 더욱 빠르게 알아낼 수 있습니다.

4. key 설정
1) key 값은 언제나 유일해야 합니다.
2) 데이터가 가진 고유값을 key 값으로 설정해야 합니다.

5. 응용 
1) 초기 상태 설정하기
2) 데이터 추가 기능 구현하기
3) 데이터 제거 기능 구현하기		

react-icons 라이브러리 -> svg 이미지 

yarn add react-icons

import {
  MdOutlineCheckBox,
  MdOutlineCheckBoxOutlineBlank,
} from 'react-icons/md';

const items = [
  { id: 1, title: '할일1', done: false },
  { id: 2, title: '할일2', done: true },
  { id: 3, title: '할일3', done: false },
];

	const Todos = () => {
	  //const listItems = items.map((item) => <li>{item.title}</li>);
	  //console.log(listItems);
	  return (
		<ul>
		  {/*listItems*/}

		  {items.map(({ id, title, done }) => (
			<li key={id}>
			  {done ? <MdOutlineCheckBox /> : <MdOutlineCheckBoxOutlineBlank />}
			  {title}
			</li>
		  ))}
		</ul>
	  );
	};
	export default Todos;

 
컴포넌트의 라이프사이클 메서드  <= 클래스형 컴포넌트 

exam04 :
	
테미널 -> 
yarn create react-app exam04  (exam03 폴더 미리 만들지 말고)

open folder -> exam04 후  exam04 폴더 안에서 터미널 열고
yarn add react-icons

yarn start 


라이프사이클 메서드의 이해
- 라이프사이클 메서드의 종류는 총 아홉 가지
- Will 접두사가 붙은 메서드는 어떤 작업을 작동하기 전에 실행되는 메서드
- Did 접두사가 붙은 메서드는 어떤 작업을 작동한 후에 실행되는 메서드
- 이 메서드들은 컴포넌트 클래스에서 덮어 써 선언함으로써 사용될 수 있습니다.
- 라이프 사이클은 마운트, 업데이트, 언마운트 카테고리로 나눕니다.

1. 마운트
	- DOM이 생성되고 웹 브라우저상에 나타나는 것을 마운트(mount)라고 합니다
	- 마운트할 때 호출하는 메서드
		1) constructor : 컴포넌트를 새로 만들 때마다 호출되는 클래스 생성자 메서드입니다.
			constructor(props) { ... }
			
		2) getDerivedStateFromProps : props에 있는 값을 state에 넣을 때 사용하는 메서드 입니다.
			static getDerivedStateFromProps(nextProps, prevState) {
			if (nextProps.value !== prevState.value) { // 조건에 따라 특정 값 동기화
				return { value: nextProps.value };
			}
			
			return null; // state를 변경할 필요가 없다면 null을 반환 
		}

		3) render : UI를 렌더링 하는 메서드입니다.
			render() { ... }
			
		4) componentDidMount : 컴포넌트가 웹 브라우저상에 나타난 후 호출하는 메서드 입니다.
			componentDidMount() { ... }
		
2. 업데이트
	- 컴포넌트는 다음과 같은 총 네 가지 경우에 업데이트 합니다.
	1) props가 바뀔 때
	2) state가 바뀔 때
	3) 부모 컴포넌트가 리렌더링될 때
	4)  this.forceUpdate로 강제로 렌더링을 트리거할 때
		
	- 컴포넌트는 다양한 이유로 업데이트 될 수 있습니다.
	1) 부모 컴포넌트에서 넘겨주는 props가 바뀔때
	2) 컴포넌트 자신이 들고 있는 state가 setState를 통해 업데이트될 때
	3) 부모 컴포넌트가 리렌더링될 때
	
	- 컴포넌트를 업데이트할 때는 다음 메서드를 호출합니다.
	1)  getDerivedStateFromProps
		- 이 메서드는 마운트 과정에서도 호출되며, 업데이트가 시작되기 전에도 호출
		- props의 변화에 따라 state 값에도 변화를 주고 싶을 때 사용합니다.
	
	2) shouldComponentUpdate
		- 컴포넌트가 리렌더링을 해야 할지 말아야 할지를 결정하는 메서드입니다.
		- true를 반환하면 다음 라이프사이클 메서드를 계속 실행하고, false를 반환하면 작업을 중지합니다. 
		
		shouldComponentUpdate(nextProps, nextState) { ... }
		
	3) render : 컴포넌트를 리렌더링합니다.
	4) getSnapshotBeforeUpdate :  컴포넌트 변화를 DOM에 반영하기 바로 직전에 호출하는 메서드
		getSnapshotBeforeUpdate(prevProps, prevState) {
			if (prevState.array !== this.state.array) {
				const { scrollTop, scrollHeight } = this.list
				
				return { scrollTop, scrollHeight };
			}
		}
		- 이 메서드에서 반환하는 값은 componentDidUpdate에서 세 번째 파라미터인 snapshot 값으로 전달받을 수 있는데, 주로 업데이트하기 직전의 값을 참고할 일이 있을 때 활용
		
	5) componentDidUpdate : 컴포넌트의 업데이트 작업이 끝난 후 호출하는 메서드
		componentDidUpdate(prevProps, prevState, snapshot) { ... }
		1) 리렌더링을 완료한 후 실행합니다.
		2) 업데이트가 끝난 직후이므로 DOM 관련 처리를 해도 무방합니다.
		3) prevProps 또는 prevState를 사용하여 컴포넌트가 이전에 가졌던 데이터에 접근할 수 있습니다.
		4) getSnapshotBeforeUpdate에서 반환한 값이 있다면 snapshot 값을 전달받을 수 있습니다.
		
3. 언마운트
	- 마운트의 반대 과정, 즉 컴포넌트를 DOM에서 제거하는 것을 언마운트(unmount)라고 합니다.
	1) componentWillUnmount : 컴포넌트가 웹 브라우저에서 사라지기 전에 호출하는 메서드 입니다.
	2) 컴포넌트를 DOM에서 제거할 때 실행합니다.
	3) componentDidMount에서 등록한 이벤트 , 타이머, 직접 생성한 DOM이 있다면 여기서 제거 작업을 해야 합니다.
		componentWillUnmount() { ... }

4. componentDidCatch 메서드
	1) 컴포넌트 렌더링 도중에 에러가 발생했을 때 애플리케이션이 먹통이 되지 않고 오류 UI를 보여 줄 수 있게 해 줍니다.
	
	componentDidCatch(error, info) {
		this.setState({
			error: true
		});
		console.log({ error, info });
	}
	
	2) error는 파라미터에 어떤 에러가 발생했는지 알려줍니다.
	3) info 파라미터는 어디에 있는 코드에서 오류가 발생했는지에 대한 정보를 줍니다.
	4) 이 메서드를 사용할 때는 컴포넌트 자신에게 발생하는 에러를 잡아낼 수 없고 자신의 this.props.children으로 전달되는 컴포넌트에서 발생하는 에러만 잡아낼 수 있습니다.

	-----ErrProcess.js--------------------
	import { Component } from 'react';

	class ErrorProcess extends Component {
	  state = {
		isError: false,
		message: '',
	  };
	  componentDidCatch(error, info) {
		console.error(error, info);
		this.setState({ isError: true, message: error.message });
	  }
	  render() {
		const { isError, message } = this.state;
		const { children } = this.props;
		return isError ? <div>{message}</div> : children;
	  }
	}
	export default ErrorProcess;
	--------------------------------------
	index.js
	--------------------------------------
	root.render(
	  <React.StrictMode>
		<ErrorProcess>
		  <App />
		</ErrorProcess>
	  </React.StrictMode>,
	);
	--------------------------------------
	LifeCycle.js
	--------------------------------------
	number.abc();
	--------------------------------------
	
	throw 에러객체 -> 에러 발생
	Error 생성자로 생성한 객체
	
	throw new Error(메세지); -> 에러발생, 실행코드 중단
    throw new Error("에러발생!!!");	
	
	에러객체.message: 메세지
	
	try {
	}catch(에러객체) {
		//에러발생시 처리할 대체 코드....
	}
	
	try {
      number.abc();  // 에러발생 가능성이 있는 코드
	  
    } catch (err) {
      alert(err.message);
      console.error(err);
      console.log('에러처리');
	  
    } finally {
		console.log('무조건 실행!!');
		// 에러가 발생하든 하지 않든 무조건 실행하는 코드
		// 로그 기록
	}

미리캔버스, 캔바  -> 이미지 사이트


Hooks
 - use로 시작하는 함수

1. UseState
1) useState는 가장 기본적인 Hook이며, 함수 컴포넌트에서도 가변적인 상태를 지닐 수 있게 해 줍니다.
2) 함수 컴포넌트에서 상태를 관리해야 한다면 이 Hook을 사용하면 됩니다.
3)  첫 번째 원소는 상태 값, 두 번째 원소는 상태를 설정하는 함수
	const [items, setItems] = useState(기본값);
	
4) 상태를 설정하는 함수에 파라미터를 넣어서 호출하면 상태값이 변경되고 컴포넌트가 리렌더링 됩니다.
	setItems(값);
	setItems((기존상태값) => ...)   <- 함수형 업데이트
	
5) useState를 여러 번 사용하기



2. useEffect
1) 리액트 컴포넌트가 렌더링될 때마다 특정 작업을 수행하도록 설정할 수 있는 Hook 
2) 클래스형 컴포넌트의 componentDidMount와 componentDidUpdate를 합친 형태로 보아도 무방
3) 마운트될 때만 실행하고 싶을 때
4) 특정 값이 업데이트될 떄만 실행하고 싶을 때
5) 뒷정리하기
- useEffect는 기본적으로 렌더링되고 난 직후마다 실행되며, 두 번째 파라미터 배열에 무엇을 넣는지에 따라 실행되는 조건이 달라집니다.
- 컴포넌트가 언마운트되기 전이나 업데이트되기 직전에 어떠한 작업을 수행하고 싶다면 useEffect에서 뒷정리(cleanup) 함수를 변환해 주어야 합니다.

  useEffect(() => {
    //componentDidMount(), componentDidUpdate() 시에
    console.log('todo, message 값 변경 - 랜더링 후');
  }, [todo, message]); // [..] 변화감지 기준

  useEffect(() => {
    console.log('마운트시 한번만 호출');
  }, []); 

3. useReducer
	- useState보다 더 다양한 컴포넌트 상황에 따라 다양한 상태를 다른 값으로 업데이트해 주고 싶을 떄 사용하는 Hook
	- 리덕스에서도 비슷하게 사용 : 전역 상태 관리

4. useMemo
1) 함수 컴포넌트 내부에서 발생하는 연산을 최적화
2) 렌더링하는 과정에서 특정 값이 바뀌었을 때만 연산을 실행하고, 원하는 값이 바뀌지 않았다면 이전에 연산했던 결과를 다시 사용하는 방식

5. useCallback
1) useCallback은 useMemo와 상당히 비슷한 함수입니다. 주로 렌더링 성능을 최적화해야 하는 상황에서 사용
2) 이 Hook을 사용하면 만들어 놨던 함수를 재사용할 수 있습니다.

6. useRef
1) useRef Hook은 함수 컴포넌트에서 ref를 쉽게 사용할 수 있도록 해 줍니다.
2) 로컬 변수 사용하기
- 로컬 변수란 렌더링과 상관없이 바뀔 수 있는 값을 의미합니다.

Hooks

1. UseState
1) useState는 가장 기본적인 Hook이며, 함수 컴포넌트에서도 가변적인 상태를 지닐 수 있게 해 줍니다.
2) 함수 컴포넌트에서 상태를 관리해야 한다면 이 Hook을 사용하면 됩니다.
3)  첫 번째 원소는 상태 값, 두 번째 원소는 상태를 설정하는 함수
4) 상태를 설정하는 함수에 파라미터를 넣어서 호출하면 상태값이 변경되고 컴포넌트가 리렌더링 됩니다.
5) useState를 여러 번 사용하기


2. useEffect
1)  리액트 컴포넌트가 렌더링될 때마다 특정 작업을 수행하도록 설정할 수 있는 Hook 
2) 클래스형 컴포넌트의 componentDidMount와 componentDidUpdate를 합친 형태로 보아도 무방
3) 마운트될 때만 실행하고 싶을 때
4) 특정 값이 업데이트될 떄만 실행하고 싶을 때
5) 뒷정리하기
- useEffect는 기본적으로 렌더링되고 난 직후마다 실행되며, 두 번째 파라미터 배열에 무엇을 넣는지에 따라 실행되는 조건이 달라집니다.
- 컴포넌트가 언마운트되기 전이나 업데이트되기 직전에 어떠한 작업을 수행하고 싶다면 useEffect에서 뒷정리(cleanup) 함수를 변환해 주어야 합니다.

3. useReducer
- useState보다 더 다양한 컴포넌트 상황에 따라 다양한 상태를 다른 값으로 업데이트해 주고 싶을 떄 사용하는 Hook

4. useMemo
1) 함수 컴포넌트 내부에서 발생하는 연산을 최적화
   -> 메모제이션 기법, 캐싱
   
2) 렌더링하는 과정에서 특정 값이 바뀌었을 때만 연산을 실행하고, 원하는 값이 바뀌지 않았다면 이전에 연산했던 결과를 다시 사용하는 방식


4/8

	팩토리얼 연산 !5 = 5 * 4 * 3 * 2 * 1

	function factorial(num) {
		if(num < 1 ) {
			return 1;
		}
		return num * factorial(num - 1);
	}
	factorial(4);
	 > 24
	 
	function factorial(num) {
		factorial.cache = factorial.cache ?? {};
		const key = `result_${num}`;
		if(factorial.cache[key]) {
			console.log("캐시이용");
			return factorial.cache[key];
		}
		
		if(num < 1 ) {
			return 1;
		}
		
		const result =  num * factorial(num - 1);
		factorial.cache[key] = result;
		console.log("캐시저장");
		return result;
	}

	factorial(10);
	VM581:15 캐시저장
	VM581:15 캐시저장
	VM581:15 캐시저장
	VM581:15 캐시저장
	VM581:15 캐시저장
	VM581:15 캐시저장
	VM581:15 캐시저장
	VM581:15 캐시저장
	VM581:15 캐시저장
	VM581:15 캐시저장
	3628800
	factorial(10);
	VM581:5 캐시이용
	3628800	
	

부모 컴포넌트가 랜더링 -> 자식 컴포넌트도 자동으로 갱신
React.memo(컴포넌트)
export default React.memo(Average);




5. useCallback
1) useCallback은 useMemo와 상당히 비슷한 함수입니다. 주로 렌더링 성능을 최적화해야 하는 상황에서 사용
2) 이 Hook을 사용하면 만들어 놨던 함수를 재사용할 수 있습니다.

6. useRef
1) useRef Hook은 함수 컴포넌트에서 ref를 쉽게 사용할 수 있도록 해 줍니다.
2) 로컬 변수 사용하기
- 로컬 변수란 렌더링과 상관없이 바뀔 수 있는 값을 의미합니다.


컴포넌트 성능 최적화

const [todos, setTodos] = useState(createBulkTodos()); //요렇게 쓰면 ...
const [todos, setTodos] = useState(createBulkTodos);

1. 느려지는 원인 분석
1) 컴포넌트는 다음과 같은 상황에서 리렌더링이 발생합니다
	- 자신이 전달받은 props가 변경될 때
	- 자신의 state가 바뀔 때
	- 부모 컴포넌트가 리렌더링될 때
	- forceUpdate 함수가 실행될 때


2. React.memo를 사용하여 컴포넌트 성능 최적화
1) 컴포넌트의 리렌더링을 방지할 때는 shouldComponentUpdate라는 라이프사이클을 사용하면 됩니다.
2) 그러나 함수 컴포넌트에서는 라이프사이클 메서드를 사용할 수 없습니다.
3) 그 대신 React.memo라는 함수를 사용합니다. 컴포넌트의 props가 바뀌지 않았다면, 리렌더링하지 않도록 설정하여 함수 컴포넌트의 리렌더링 성능을 최적화해 줄 수 있습니다.

3. 함수가 바뀌지 않게 하기
1) 함수가 계속 만들어지는 상황을 방지하는 방법은 두 가지 입니다.
- useState의 함수형 업데이트 기능을 사용하는 것
- useReducer를 사용하는 것  : 컴포넌트 바깥에 선언되므로 매번 호출되지 않는다


2) useState의 함수형 업데이트
- 새로운 상태를 파라미터로 넣는 대신, 상태 업데이트를 어떻게 할지 정해주는 업데이트 함수를 넣어줄 수도 있습니다. 이를 함수형 업데이트라고 합니다.
  => useCallback과 함께 사용시 매번 함수정의 되지 않도록
  

const [number, setNumber] = useState(0);
// prevNumber는 현재 number 값을 가리킵니다.
const onIncrease = useCallback(
    () => setNumber(prevNumber => prevNumber + 1),
);

- setNumber(number+1)을 하는 것이 아니라, 어떻게 업데이트할지 정의해 주는 업데이트 함수를 넣어줍니다.
- 그러면 useCallback을 사용할 때 두 번째 파라미터로 넣는 배열에 number를 넣지 않아도 됩니다.

3) useReducer 사용하기
- useState의 함수형 업데이트를 사용하는 대신 useReducer를 사용해도 onToggle, onRemove가 계속 새로워지는 문제를 해결할 수 있습니다.
-  두 번쨰 파라미터에 undefined를 넣고 세 번째 파라미터에 초기 상태를 만들어 주는 함수인 createBulkTodos를 넣어 주었는데, 이렇게 하면 컴포넌트가 맨 처름 렌더링될 때만 createBulkTodos 함수가 호출됩니다.
4) useMemo


4. react-virtualized를 사용한 렌더링 최적화 => 나중에


immer를 사용하여 더 쉽게 불변성 유지하기


	const person = {
		name: 'hjchoi',
		age: 40,
		address : {
			zipcode: '1234',
			addr1: '주소1',
			addr2: '주소2'
		}

	}
	const person2 = {...person};  //중첩된 객체는 이렇게 하위 객체까지 깊은 복사 안됨
	const person3 = { ...person, address: { ...person.address}}; //이렇게 해 줘야 address 까지 깊은 복사가 된다.
	-> 너무 복잡하고 깊이가 여러 단계로 중첩되면 일일히 못하므로 immer 를 쓴다
	블변성 유지

1. immer를 설치하고 사용법 알아보기
1) 설치
	- yarn add immer  ( npm i immer )

2) immer를 사용하지 않고 불변성 유지
3) immer 사용법
	import { produce } from 'immer';
	const nextState = produce(originalState, draft => {
		// 바꾸고 싶은 값 바꾸기
		draft.somewhere.deep.inside = 5;
	})
	
	- 두 번째 파라미터로 전달되는 함수 내부에서 원하는 값을 변경하면, produce 함수가 불변성 유지를 대신해 주면서 새로운 상태를 생성해 줍니다.
	- 이 라이브러리의 핵심은 '불변성에 신경 쓰지 않는 것처럼 코드를 작성하되 불변성 관리는 제대로 해주는 것'입니다. 
	- 단순히 같은 곳에 위치하는 값을 바꾸는 것 외에 배열을 처리할 때도 매우 쉽고 편합니다.

4) useState의 함수형 업데이트와 immer 함께 쓰기
- immer에서 제공하는 produce 함수를 호출할 때, 첫 번째 파라미터가 함수 형태라면 업데이트 함수를 반환


const person = {
    name: 'hjchoi',
    age: 40,
    address : {
        zipcode: '1234',
        addr1: '주소1',
        addr2: '주소2'
    }

}
const person2 = {...person};  //중첩된 객체는 이렇게 하위 객체까지 깊은 복사 안됨
const person3 = { ...person, address: { ...person.address}}; //이렇게 해 줘야 address 까지 깊은 복사가 된다.
-> 너무 복잡하고 깊이가 여러 단계로 중첩되면 일일히 못하므로 immer 를 쓴다
블변성 유지




일급함수 
 - 함수와 변수 를 동등하게 취급한다.
 - 함수는 값으로 사용
	1) 매개변수
	2) 반환값 - 클로저, 고차함수
	

yarn create react-app exam05

	
컴포넌트 스타일링

1. Sass 사용하기
1) 설명 
- Sass(Syntactically Awesome Style Sheets)(문법적으로 매우 멋진 스타일시트)
- CSS 전처리기로 복잡한 작업을 쉽게 할 수 있도록 해 주고, 스타일 코드의 재활용성을 높여 줄 뿐만 아니라 코드의 가독성을 높여서 유지 보수를 더욱 쉽게 해 줍니다.
- 두 가지 확장자 .scss와 .sass를 지원
	scss -> 세미콜론 사용가능, 중괄호 가능

- .sass 확장자는 중괄호({})와 세미콜론(;)을 사용하지 않습니다.
- Sass를 사용하려면 sass라는 라이브러리를 설치해 주어야 합니다. 이 라이브러리는 Sass를 CSS로 변환해 줍니다.

2) 설치 
- yarn add sass

3) utils 함수 분리하기
- 여러 파일에서 사용될 수 있는 Sass 변수 및 믹스인을 다른 파일로 분리하여 작성한 뒤 필요한 곳에서 쉽게 불러와 사용할 수 있습니다.

git add .
git commit -m "...."
yarn eject
-> y

@import("스타일 시트 경로")


2. CSS Module
1) [파일이름]_[클래스 이름]__[해시값] 형태로 자동으로 만들어서 컴포넌트 스타일 클래스 이름이 중첩되는 현상을 방지해 주는 기술
2) .module.css 확장자로 파일을 저장하기만 하면 CSS Module이 적용
   .module.scss

3. classnames
1) CSS 클래스를 조건부로 설정할 떄 매우 유용한 라이브러리
yarn add classnames

2) classnames 간략 사용법
3) Sass와 함께 사용하기
	- Sass를 사용할 때도 파일 이름 뒤에 .module.scss 확장자를 사용해 주면 CSS Module로 사용할 수 있습니다.
	
4) CSS Module이 아닌 파일에서 CSS Module 사용하기
	- CSS Module에서 글로벌 클래스를 정의할 때 :global을 사용했던 것처럼 CSS Module이 아닌 .css/.scss 파일에서도 :local을 사용하여 CSS Module을 사용할 수 있습니다.
	
3. styled-components
1) 자바스크립트 파일 안에 스타일을 선언하는 방식 / CSS-in-JS라고 부릅니다.
yarn add styled-components

참고)
yarn add sass classnames styled-components

2) styled-components와 일반 classNames를 사용하는 CSS/Sass를 비교했을 때, 가장 큰 장점은 props 값으로 전달해 주는 값을 쉽게 스타일에 적용할 수 있다는 것입니다.
3) Tagged 템플릿 리터럴
	- Tagged 템플릿 리터럴을 사용하면 템플릿 사이사이에 들어가는 자바스크립트 객체나 함수의 원본 값을 그대로 추출할 수 있습니다.
	- styled-components는 이러한 속성을 사용하여 styled-components로 만든 컴포넌트의 props를 스타일 쪽에서 쉽게 조회할 수 있도록 해줍니다.
4) 스타일링된 엘리먼트 만들기
	- styled.div 뒤에 Tagged 템플릿 문법을 통해 스타일을 넣어 주면, 해당 스타일이 적용된 div로 이루어진 리액트 컴포넌트가 생성
	- div가 아닌 button이나 input에 스타일링을 하고 싶다면 styled.button 혹은 styled.input 같은 형태로 뒤에 태그명을 넣어 주면 됩니다.
	- 사용해야 할 태그명이 유동적이거나 특정 컴포넌트 자체에 스타일링할 경우 다음과 같은 형태로 구현할 수 있습니다.

	const StyledLink = styled(Link)`
		color: blue;
	`;
	
5) 스타일에서 props 조회하기

const Box = styled.div`
	/* props로 넣어 준 값을 직접 전달해 줄 수 있습니다. */
	background: ${props => props.color || 'blue'};
	padding: 1rem;
	display: flex;
`;

<Box color="black">...</Box>


6) props에 따른 조건부 스타일링	


4/9

정규표현식

Regexp

/패턴/ -> 정규 표현식 객체 

	test()	: 패턴의 일치 여부 체크(true, false)
	exec() : 서브 패턴 : 일치하는 문자열을 추출 
	
[0-9] : 숫자  === \d
[^0-9] : 숫자가 아닌 패턴 === \D

\s : 공백 1개
\S : 공백이 아닌 패턴 -  [^\s]

* : 패턴이 0개 이상 적용 - 있어도 되고 없어도 되고
+ : 패턴이 1개 이상 적용 

\s* -> 0개 이상의 공백 패턴
\s+ -> 1개 이상의 공백 패턴

\w  -> [a-zA-Z0-9_]
\W -> [^a-zA-Z0-9_]

패턴{시작 횟수, 종료 횟수}
\d{3,4} -> 숫자가 3~4자리 사이 패턴 

패턴{횟수}  -> 횟수만큼 패턴 
\d{3} -> 숫자가 3자리

패턴{횟수,} -> 횟수 이상 
\d{2,} -> 숫자가 2자리 이상 

\d*  -> \d{0,}
\d+ -> \d{1,}


^패턴 : 패턴으로 시작

^01  -> 01로 시작하는 패턴 
패턴$ : 패턴으로 종료

\d{4}$ -> 숫자 4자리로 종료되는 패턴

-> 010-1234-1234 -> 숫자가 아닌 패턴은 제거 -> 숫자만 남겨서 패턴 체크

휴대폰 번호 

플래그 
i : caseincensitve : 대소문자 구분 X [a-zA-Z] -> 알파벳(대소문자)
	/[a-z]/i
g : 검색 범위를 전역 변경 
m : 멀티 라인

패턴?  --  패턴{0,1} ->패턴이 있어도 되고 없어도 되는 패턴


. : 문자 한개(줄개행 문자 제외)

서브 패턴 -> (...)

컴포넌트 스타일링

0. CSS 사용 
import 'CSS 경로';

yarn create react-app exam05
npm init react-app exam05

자손 조상 

p .red {

}



1. Sass 사용하기
1) 설명 
- Sass(Syntactically Awesome Style Sheets)(문법적으로 매우 멋진 스타일시트)
- CSS 전처리기로 복잡한 작업을 쉽게 할 수 있도록 해 주고, 스타일 코드의 재활용성을 높여 줄 뿐만 아니라 코드의 가독성을 높여서 유지 보수를 더욱 쉽게 해 줍니다.
- 두 가지 확장자 .scss와 .sass를 지원
	scss -> 세미콜론 사용 가능, 중괄호 가능 

- .sass 확장자는 중괄호({})와 세미콜론(;)을 사용하지 않습니다.
- Sass를 사용하려면 sass라는 라이브러리를 설치해 주어야 합니다. 이 라이브러리는 Sass를 CSS로 변환해 줍니다.



2) 설치 
- yarn add sass
-  npm i sass 

3) utils 함수 분리하기
- 여러 파일에서 사용될 수 있는 Sass 변수 및 믹스인을 다른 파일로 분리하여 작성한 뒤 필요한 곳에서 쉽게 불러와 사용할 수 있습니다.

git add .
git commit -m "...."
yarn eject
-> y

@import("스타일 시트 경로")


2. CSS Module
1) [파일이름]_[클래스 이름]__[해시값] 형태로 자동으로 만들어서 컴포넌트 스타일 클래스 이름이 중첩되는 현상을 방지해 주는 기술
2) .module.css 확장자로 파일을 저장하기만 하면 CSS Module이 적용



3. classnames
1) CSS 클래스를 조건부로 설정할 떄 매우 유용한 라이브러리
yarn add classnames
npm i classnames

	import classNames from 'classnames/bind';

2) classnames 간략 사용법
3) Sass와 함께 사용하기
	- Sass를 사용할 때도 파일 이름 뒤에 .module.scss 확장자를 사용해 주면 CSS Module로 사용할 수 있습니다.
	
4) CSS Module이 아닌 파일에서 CSS Module 사용하기
	- CSS Module에서 글로벌 클래스를 정의할 때 :global을 사용했던 것처럼 CSS Module이 아닌 .css/.scss 파일에서도 :local을 사용하여 CSS Module을 사용할 수 있습니다.
	
3. styled-components 
1) 자바스크립트 파일 안에 스타일을 선언하는 방식 / CSS-in-JS라고 부릅니다.
yarn add styled-components   (s 꼭 붙이기)

참고)
yarn add sass classnames styled-components   


	import styled from 'styled-components';

	const InputBox= styled.input`
		display:block;
		height: 45px;
		border: 1px solid #ccc;
		border-radius: 5px;
	`;

	<InputBox type="text" placeholder="아이디" />

2) styled-components와 일반 classNames를 사용하는 CSS/Sass를 비교했을 때, 가장 큰 장점은 props 값으로 전달해 주는 값을 쉽게 스타일에 적용할 수 있다는 것입니다.
3) Tagged 템플릿 리터럴
	- Tagged 템플릿 리터럴을 사용하면 템플릿 사이사이에 들어가는 자바스크립트 객체나 함수의 원본 값을 그대로 추출할 수 있습니다.
	- styled-components는 이러한 속성을 사용하여 styled-components로 만든 컴포넌트의 props를 스타일 쪽에서 쉽게 조회할 수 있도록 해줍니다.
	
	 // LoginForm.js
	<BigButton type="submit" buttoncolor="blue">로그인</BigButton>  

	//ButtonStyle.js
	import styled from 'styled-components';
	export const BigButton = styled.button`
	  background: ${(props => props.buttoncolor)};
	`;	
	
	==(비구조화할당으로 쓰면)  background: ${( {buttoncolor}) => buttoncolor ?? 'orange'};


참고: 역따옴표..---------
tagged 함수

function tagged(...params) {
    console.log(params);
}

tagged`텍스트 어쩌구저쩌구~~`;

const a = 10, b = 'abc';
tagged`출력: ${a}, ${b}`;

tagged`${a}, ${b}, ${(props) => console.log(props)}`;

---------



4) 스타일링된 엘리먼트 만들기

	- styled.div 뒤에 Tagged 템플릿 문법을 통해 스타일을 넣어 주면, 해당 스타일이 적용된 div로 이루어진 리액트 컴포넌트가 생성
	- div가 아닌 button이나 input에 스타일링을 하고 싶다면 styled.button 혹은 styled.input 같은 형태로 뒤에 태그명을 넣어 주면 됩니다.
	- 사용해야 할 태그명이 유동적이거나 특정 컴포넌트 자체에 스타일링할 경우 다음과 같은 형태로 구현할 수 있습니다.

	const StyledLink = styled(Link)`
		color: blue;
	`;
	
5) 스타일에서 props 조회하기

const Box = styled.div`
	/* props로 넣어 준 값을 직접 전달해 줄 수 있습니다. */
	background: ${props => props.color || 'blue'};
	padding: 1rem;
	display: flex;
`;

<Box color="black">...</Box>


6) props에 따른 조건부 스타일링

리액트 라우터로 SPA 개발하기
1. 라우팅이란?
1) 사용자가 요청한 URL에 따라 알맞는 페이지로 보여주는 것을 의미
2) 여러 페이지로 구성된 웹 애플리케이션을 만들 때 페이지별로 컴포넌트들을 분리해가면서 프로젝트를 관리하기 위해 필요한 것이 라우팅 시스템
- 리액트 라우터(React Router) : CSR(Client Side Rendering) 



2. SPA란?
1) SPA(Single Page Application) : 싱글페이지 애플리케이션
2) 한 개의 페이지로 이루어진 애플리케이션
3) 리액트 같은 라이브러리를 사용해서 뷰 렌더링을 사용자의 브라우저가 담당하도록 하고, 우선 웹 애플리케이션을 브라우저에 불러와서 실행시킨 후에 사용자와 인터렉션이 발생하면 필요한 부분만 자바스크립트를 사용하여 업데이트하는 방식을 사용하게 됩니다.
4) 싱글 페이지 애플리케이션은 기술적으로는 한 페이지만 존재하는 것이지만, 사용자가 경험하기에는 여러 페이지가 존재하는 것 처럼 느낄 수 있습니다.
5) 브라우저의 History API를 사용하여 브라우저의 주소창의 값만 변경하고 기존 페이지에 띄웠던 웹 애플리케이션을 그대로 유지하면서 라우팅 설정에 따라 다른 페이지를 보여줍니다.

리액트 라우터 적용 및 기본 사용법

1. 라이브러리 설치
	yarn add react-router-dom
	
2. 프로젝트에 라우터 적용
1) src/index.js 파일에서 react-router-dom에 내장되어 있는 BrowserRouter라는 컴포넌트를 사용하여 감싸면 됩니다.
2) 이 컴포넌트는 웹 애플리케이션에 HTML5의 History API를 사용하여 페이지를 새로 불러오지 않고도 주소를 변경하고 현재 주소의 경로에 관련된 정보를 리액트 컴포넌트에서 사용할 수 있도록 해줍니다.

3. 페이지 컴포넌트 만들기

4. Route 컴포넌트로 특정 경로에 원하는 컴포넌트 보여주기

1) Route 컴포넌트는 다음과 같이 사용합니다.
	<Route path="주소규칙" element={보여 줄 컴포넌트 JSX} />
2) Route 컴포넌트는 Routes 컴포넌트 내부에서 사용되어야 합니다.

	App.js
	-----------------
	import { Routes, Route } from 'react-router-dom';

	import Home from './pages/Home';
	import About from './pages/About';

	const App = () => {

	  return (
		<Routes>
		  <Route path="/" element={<Home />} />
		  <Route path="/about" element={<About />} />
		</Routes>
	  );
	};

	export default App;
	-------------------
5. Link 컴포넌트를 사용하여 다른 페이지로 이동하는 링크 보여주기
1) <Link to="경로">링크 이름</Link>
	- a태그 : 기본기능 안씀, History API로 기능 수정
	   (e.preventDefault() )

6. URL 파라미터와 쿼리스트링
1) URL 파라미터 ( = 경로변수 )

- 주소의 경로에 유동적인 값을 넣는 형태
- 주로 ID또는 이름을 사용하여 특정 데이터를 조회할 때 사용
- 예) /profile/이름
- useParams()

- URL 파라미터는 /profiles/:username과 같이 경로에 :를 사용하여 설정합니다. 만약 URL 파라미터가 여러개인 경우엔 /profiles/:username/:field와 같은 형태로 설정할 수 있습니다.

	http:// ..../board/1 

	import { useParams } from 'react-router-dom';
	~ ~ ~
	const { id } = useParams();




2) 쿼리스트링
- 주소의 뒷부분에 ? 문자열 이후 key=value로 값을 정의하며 &로 구분을 하는 형태
- 키워드 검색, 페이지네이션, 정렬 방식 등 데이터 조회에 필요한 옵션을 전달할 때 사용
- 예) /articles?page=1&keyword=react
- useLocation()

- 쿼리스트링을 사용할 때는 URL 파라미터와 달리 Route 컴포넌트를 사용할 때 별도로 설정해야 하는 것은 없습니다.

- useLocation Hook은 location 객체를 반환하며 이 객체는 현재 사용자가 보고있는 페이지의 정보를 지니고 있습니다.
- 쿼리스트링은 location.search 값을 통해 조회를 할 수 있습니다.
- 리액트 라우터에서는 useSearchParams라는 Hook을 통해서 쿼리스트링을 더욱 쉽게 다룰 수 있게 됩니다.
- useSearchParams는 배열 타입의 값을 반환하며, 첫번째 원소는 쿼리파라미터를 조회하거나 수정하는 메서드들이 담긴 객체를 반환합니다.

	js:  URLSearchParams
	콘솔
	const params = new URLSearchParams(location.search);
	params.get('key1');
	params.append("key3","value3");
	params.toString();


- const [searchParams, setSearchParams] = useSearchParams();
- 쿼리파라미터를 사용할 때 유의점은 쿼리파라미터를 조회할 때 값은 무조건 문자열 타입입라는 것. true 또는 false 값을 넣게 된다면 값을 비교할 때 꼭 'true'와 같이 따옴표로 감싸서 비교를 해야 하며, 숫자를 다룰때는 parseInt를 사용하여 숫자 타입으로 변환해야 한다.

7. 중첩된 라우트
1) Outlet 컴포넌트가 사용된 자리에 중첩된 라우트가 보여지게 됩니다.
	/board -> 
	/board/view/:id ->

	/member/login
	/member/join
	
	/member
	  login
	  join




8. 공통 레이아웃 컴포넌트
1) 중첩된 라우트와 Outlet은 페이지끼리 공통적으로 보여줘야 하는 레이아웃이 있을때도 사용할 수 있습니다.

	------------------------------------
	App.js
	const App = () => {
	  return (
		<Routes>
		  <Route path="/" element={<MainLayout />}>
			<Route path="home" element={<Home />} />       : 중첩부분
			<Route path="about" element={<About />} />     : 중첩부분
		  </Route>
		</Routes>
	  );
	};

	------------------------------------
	MainLsyout.js

	import React from 'react';
	import { Outlet } from 'react-router-dom';

	const MainLayout = () => {
	  return (
		<>
		  <header>
			<h1>헤더 영역</h1>
		  </header>
		  <main>
			<Outlet />                   : 요 자리에 중첩부분만 바뀜
		  </main>
		  <footer>
			<h1>풋터 영역</h1>
		  </footer>
		</>
	  );
	};
	export default React.memo(MainLayout);
	------------------------------------



9. index props
1) Route 컴포넌트에는 index라는 props가 있습니다. 이 props는 path="/"와 동일한 의미를 가집니다.
2) index props는 상위 라우트의 경로와 일치하지만, 그 이후에 경로가 주어지지 않았을 때 보여지는 라우트를 설정할때 사용합니다.
3) path="/"와 동일한 역할을 하며 이를 좀 더 명시적으로 표현하는 방법입니다.

리액트 라우터 부가기능
1. useNavigate 
1) Link 컴포넌트를 사용하지 않고 다른 페이지로 이동을 해야 하는 상황에 사용하는 Hook 입니다.
2) navigate 함수를 사용할 때 파라미터가 숫자 타입이라면 앞으로 또는 뒤로 이동합니다.
	- navigate(-1) : 뒤로 한번 이동  // history.back()
	- navigate(1) : 앞으로 한번 이동(뒤로가 한번 한 후 동작)
	
3) 다른 페이지로 이동을 할 때 replace 옵션을 사용하면 페이지 이동 기록이 남지 않습니다.
	const goArticles = () => {
		navigate('/articles', { replace: true });  -> 방문기록 남기지 않고 이동
	};
	location.assign(..) , location.href
	location.replace(..) 


2. NavLink
1) NavLink 컴포넌트는 링크에서 사용하는 경로가 현재 라우트 경로와 일치하는 경우 특정 스타일 또는 CSS 클래스를 적용하는 컴포넌트입니다.
2) 이 컴포넌트를 사용할 때 style 또는 className을 설정할 때 { isActive: boolean }을 파라미터로 전달받는 함수 타입의 값을 전달합니다.

3. NotFound 페이지 만들기
1) *는 와일드카드 문자, 아무 텍스트나 매칭한다는 의미
2) 라우트 요소의 상단에 위치하는 라우트들의 규칙을 모두 확인하고, 일치하는 라우트가 없다면 이 라우트가 화면에 나타나게 됩니다.

4. Navigate 컴포넌트
1) Navigate 컴포넌트는 컴포넌트를 화면에 보여주는 순간 다른 페이지로 이동을 하고 싶을 때 사용하는 컴포넌트입니다. 즉, 페이지를 리다이렉트 하고 싶을 때 사용
	if (!isLoggedIn) {
		return <Navigate to="/login" replace={true} />;
	}
	
코드 스플리팅

	SPA -> 모든 컴포넌트 전부 로드하는 문제 -> 초기로딩 느린 단점

1. React.lazy와 Suspense를 통한 컴포넌트 코드 스플리팅 
	필요할때만 로딩
	
	지연로딩 

2. Loadable Components를 통한 코드 스플리팅

	개발자도구 네트워크 -> 제한없음 화살표 눌러 지연로딩 상황 만들 수 있다.. 느린3G 
	이보다
	yarn add @loadable/component
	
	이거 씀
	