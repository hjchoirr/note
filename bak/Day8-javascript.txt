function Person (){
    this.name = '이이름';
    this.age = 20;
}
Person.prototype.showInfo = function () {
    console.log("이름" , this.name, "나이", this.age);
}
person.method = function () {
    console.log("기능!");
}
const p1 = new Person();
p1.showInfo();
p.method();
p1;
Person;
console.dir(Function);
console.dir(Person);
Person.method;
console.dir(Person.method);
VM1045:1 undefined
undefined
typeof Person;
'function'
Person instanceof Function;
true
---------------------------
class Person {
    constructor (name, age) {
        this.name = '이이름';
        this.age = 40;
    }
    showInfo() {
        console.log("이름", this.name);
    }
    static method () {
        console.log("기능!");
    }
};
console.dir(Person);
undefined
const p1 = new Person();
p1;
p1.showInfo();
p1.method();
---------------------------

class Elipse {
    constructor(a,b) {
        this.a = a;
        this.b = b;
    }
    area() {
        console.log("면적:", this.a * this.b * Mat.PI);
    }
}
class Circle extends Elipse {
    constructor(r) {
        super(r,r);
    }
}

undefined
const c1 = new Circle();
------------------------------
function Elipse(a, b) {
    this.a = a;
    this.b = b;
}
Elipse.prototype.area = function() {
    console.log("면적", this.a * this.b * Math.PI);
}
    

ƒ () {
    console.log("면적", this.a * this.b * Math.PI);
}
function Circle(r) {
    Elipse.call(this, r, r);
}
Circle.prototype.__proto__ = Elipse.prototype;
Circle.prototype.constructor = Circle;
------------------------------


코어객체
	내장 생성자객체
	
	내장객체

호스트객체
	웹브라우저객체
	window
		location
		history
		screen
		navigator
		document
		...
		

내장 생성자
- 자바스크립트에 처음부터 포함된 내장 생성자
1. Object
	Object.prototype
	const 변수명 = new Object();
	=>
	{..};  // 짧게 사용가능
	
	prototype	
		.toLocaleString() 
		
			Locale : 지역화
			- 지역화에 맞게 변경 -> 출력
			
		Object.getOwnPropertyDescriptor()
		Object.getOwnPropertyDescriptors()
	
		데이터 프로퍼티
			value - 값
			writable : false면 값변경 불가
			enumerable : false면 열거 불가
			configurable : false면 설정변경 불가, 삭제 불가
						 false 라도 예외..
						 writable true-> 단 한번만 fasle로 변경 가능
						 
			-> 변경
			Object.defineProperty
			Object.defineProperties
			
			Object.preventExtensions()

			const person = {
				name: "이믈",
				age : 40
			};
			for(const key in person) {
				console.log(key);
			}
			Object.preventExtensions(person);
			person.address = '주소';
			person;
			
			
			Object.seal() : 객체를 밀봉 (삭제불가, 속성추가 불가, 값변경 가능)
			Object.freeze() : 객체를 동결 (삭제불가, 속성추가 불가, 값변경 불가)
			
			참고) 속성: 통제 기능 포함
		
		접근자 프로퍼티
			- 함수형태: 단축 표현법
			- set 함수명 - 값을 변경하는 접근자 속성
			- get 함수명 - 값을 조회하는 접근자 속성
			- enumerable
			- configurable


			const schedule = {
				_year : 2024,
				_month : 3,
				_day : 28,

				set year(year) {
					this._year = year;
				},
				get year() {
					return this._year;
				},
				set month(month) {
					this._month = month;
				},
				get month() {
					return this._month;
				},
				set day(day) {
					if(this._month == 2 && day > 28) {
						day = 28;
					}
					this._day = day;
				},
				get day() {
					return this._day;
				}
			}
			
			schedule.year;
			2024
			schedule.year = 2023;
			2023
			schedule.year;
			2023
			schedule.month = 2;
			2
			schedule.day = 31;
			31
			schedule;
			{_year: 2024, _month: 2, _day: 28, …}	


			const schedule = ( function(){
				let _year = 2024;
				let _month = 3;
				let _day = 28;

				return {
					set year(year) {
						_year = year;
					},
					get year() {
						return _year;
					},
					set month(month) {
						_month = month;
					},
					get month() {
						return _month;
					},
					set day(day) {
						_day = day;
					},
					get day() {
						return _day;
					},
				}
			})();
			----------------------------------------
			schedule;
			{}
			schedule.year;
			2024
			schedule.year=2023;
			2023
			schedule.year;
			2023			
			
			const person = {
				name:'이이름',
				age: 40
			}
			const person2 = person; //얕은 복사, 주소복사
			person === person2;
			true
			const person3 = Object.assign({}, person); //깊은복사
			person === person3;
			false	

			----------------------------------------
			전개연산자... : 깊은복사 기능
			const person = {
				name:'이이름',
				age: 40
			}
			const person2 = { ...person };
			person === person2;
			false			
			----------------------------------------
			const person = {
				name:'이이름',
				age: 40
			}
			undefined
			const person2 = { ...person };
			person === person2;
			false
			const person2 = { ...person, age: 30 };
			undefined
			person2;
			{name: '이이름', age: 30}

		(참고)
			entries : 이름-값 쌍 조회
			Map.Entry : 이름-값의 쌍
			
			const person = {
				name:'이읆',
				age: 40
			}
			for(const entry of Object.entries(person)) {
				console.log(entry);
			}
		
			Object.keys(person);
			Object.values(person);
			
			
			
원시타입, 원시값 - 재료가 되는 값

숫자
문자
논리값 
undefined
null
...
		
2. String 
	wrapper 생성자 객체
		const str = 'abc';   <= const str = new Srting('abc');
		str.toUpperCase();   <= String 생성해서 바꾸고 다시 원시 변환함  
	
	indexOf(..)  : 문자열의 ..가 있는 첫번째 위치번호  a.indexOf('little') 
	lastIndexOf(..) : 문자열의 ..가 있는 첫번째 위치번호(우->좌 방향으로 찾기)
	-> 문자열 찾지 못하면 -1 반환
	
	replace : 
		const c = 'abcAbc345';
		const d = c.replace(/b/g, 'BB');
		-> 'aBBcABBc345'
	concat
	trim
	
3. Number 
	wrapper 생성자 객체
	NaN : Not a Number - 숫자가 아니다
		isNaN(...): 숫자형식이 아니면 true (데이터타입의 문제 아님) 
	isNaN(123);
	false  -> 숫자다
	isNaN('123');  
	false  -> 숫자다  
	isNaN('abcd');
	true  -> 숫자아니다
	Number("cdscds")
	NaN	  -> 숫자아니다
	
	const num1 = '123';
	const num2 = Number(num1); 문자열을 숫자로 변환 하는 과정에 isNaN 사용
	
	typeof num1 === 'number' : 숫자 판별 가능
	
	const num1 = '123';
	typeof num1;
	'number'
	
	parseInt(문자열|실수) => 정수로변환
	parseFloat(문자열) => 실수로 변환
	int : 정수 
	float : 실수
	
	const num1 = '123';
	const num2 = parseInt(num1);   //parseInt는 window 전역내장함수
	num2;
	123
	
	parseInt(num1) === Number.parseInt(num1);
	
	parse -> 형변환(변경)
	
	const num1 = 10.12345;
	const num2 = num1.toFixed(2);
	num2;
	'10.12'	
	
	
4. Boolean 
	0, -0, null, false, NaN, undefined, 빈 문자열 ("")이라면 객체의 초기값은 false

	const num1 = 0;
	typeof num1;
	'number'
	const bool1 = Boolean(num1);
	bool1;
	false
	Boolean(1);
	true	

5. Array
	const 변수명 = new Array(...) ;
	=>
	[...];  // 짧게 사용가능
	=>
	Array.prototype
	
	- 배열X, 배열객체O
	  (참고)배열이란 같은 자료형이 연속해서 나열된 형태
	
6. Date
	-날짜와 시간
	const date = new Date(); //객체 생성시점의 날짜와 시간
	undefined
	date;
	Fri Mar 29 2024 14:36:08 GMT+0900 (한국 표준시)	
	
	date.getUTCDate();
	29
	date.getFullYear()
	2024
	date.getMonth()
	2
	date.getDate()
	29
	date.getDay()
	5
	date.getHours()
	14
	date.getMinutes()
	36
	date.getSeconds()
	8	
	
	const strDate = `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}`;
	strDate
	'2024-3-29'
	
	const strTime = `${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}`;
	strTime;
	'14:36:8'	
	
		- getFullYear() / setFullYear()
		- getMonth() // 0~11월  /setMonth()
	
	date.setFullYear(2023);
	1680068168711
	date;
	Wed Mar 29 2023 14:36:08 GMT+0900 (한국 표준시)	
	
	date.setDate(date.getDate() - 7); //7일전
	1679463368711
	date;
	Wed Mar 22 2023 14:36:08 GMT+0900 (한국 표준시)	
	
	const date = new Date();
	date.getTime(); // 1970.1.1 자정부터 1000분의 1초 단위로 카운트한 숫자 -> Epoch Time -> 초단위 -> Timestamp
	                -> 사용예) 유일한 아이디 만들때 UID 등으로
	const date = new Date();
	date.getTime();  //현재시간의 epoch time
	1711691687687

	Date.now();
	1711691905071
	
	- Date.parse(문자열 날짜) : 문자열 날짜 -> Date 객체로 변환
	
	const d3 = Date("3 29 2024");
	d3;
	'Fri Mar 29 2024 15:21:06 GMT+0900 (한국 표준시)'

	const strDate = '2021-11-01T11:59:30';
	const d1 = Date.parse(strDate);
	d1;
	1635735570000
	const d2 = new Date(d1);
	d2;
	Mon Nov 01 2021 11:59:30 GMT+0900 (한국 표준시)	  

	생성자 Date
	
	const d1 = new Date(2021, 2, 29);
	d1;
	Mon Mar 29 2021 00:00:00 GMT+0900 (한국 표준시)
	
	
	- new Date(year, monthIndex, day, hours, minutes, seconds, milliseconds);
	
	달력
	1) 이번달이 몇일로 끝나는지
	2) 이번달 1일 무슨 요일인지

		-> 다음달 1일에서 - 1일
		-> getDay()
	
7. Function

	apply
	call
	bind

	function add(num1, num2) {
		return num1 + num2;
	}
	undefined
	const add10 = add.bind(this, 10);
	undefined
	add10(20);
	30
	
	const person = {
		name : 'hjchoi',
		age: 40
	}
	function showInfo() {
		console.log(this.name, this.age);
	}
	showInfo = showInfo.bind(person);

	showInfo();
	
	hjchoi 40	

8. RegExp - 나중에
9. Error 
	try {
	
	} catch(e) {
	
	}


ES6부터 추가된 주요 내장 생성자   ****
1. Symbol
2. Promise  : 리액트할때

콜렉션 프레임워크 - 자바할때
3. Map
4. Set

기타 내장 객체
JSON (Javascript Object Notation) - 자바스크립트 객체 표기법
 {
	"이름": "값",
	"이름": "값",
	...
 }
 
 .parse(...) 
   - JSON 문자열 -> 자바스크립트 객체로 변환
 .stringify(...) : 자바스크립트 객체 -> JSON 문자열로 변환
 
	const person = {
		name : 'hjchoi',
		age: 40
	}
	JSON.stringify(person);
	'{"name":"hjchoi","age":40}'
	const str = JSON.stringify(person);
	str;
	'{"name":"hjchoi","age":40}'
	JSON.parse(str);
	{name: 'hjchoi', age: 40} 
   
Math 
	- 수학관련 편의함수, 상수 정의되어 있음 
	- (PI 원주율) 
	- round(..)   Math.round(10.5)
	- floor(..)버림
	- ceil(..) 올림
	- abs(..) 절대값
	- sqrt(..)

전역 객체
1. 전역 프로퍼티
	- undefined, NaN, Infinity

2. 생성자 
	Object(), String(), Number() 등

3. 전역 함수
	parseInt(), parseFloat(), isNaN() 등 

4. 내장 객체
	Math, JSON, Reflect


자바 스크립트 객체의 분류


배열
1. 배열의 기초
- Array 생성자로 만들어진 객체 
- 데이터군
- 여러데이터
참고) 배열 아니고 배열처럼 생긴 Array객체 
	<- 같은 자료형의 순차적 나열구조 가 아니므로
	
		const fruits = new Array("Apple", "Orange", "Melon");
		fruits;

1) 배열 리터럴로 생성하기
const 배열명 = [....]; // new Array(...)

		const fruits2 = ["Apple", "Orange", "Melon"];
		fruits2;


2) length 프로퍼티
	- 배열공간의 갯수

		const fruits2 = ["Apple", "Orange", "Melon"];
		fruits2.length;
		3	
	참고) 객체의 속성명이 변수명 규칙과 어긋나면 [ ]이용하여 순서로 지정 
		fruits2[0], fruits2[1], fruits2[3]  
	
	fruits2[3] = 'manggo';
	delete fruits2[0];
	true
	fruits2
	(4) [비어 있음, 'Orange', 'Melon', 'Manggo']	
	

3) Array 생성자로 생성하기
const 배열명 = new Array(3); 
- 매개변수가 1개일때는 배열 공간의 갯수
- 양의 정수 숫자 가능 
- 매개변수가 여러개 일때는 갯수만큼 공간이 생성, 값이 순서대로 추가 

4) 배열 요소의 참조
5) 배열은 객체
6) 배열 요소의 추가와 삭제
	- 추가 
		push(...items) : 끝에 추가
		unshift(...items) : 앞에 추가 
		
	- 삭제
		pop() : 가장 끝에 요소 꺼내기 
		shift() : 가장 앞에 요소를 꺼내기
		
	- 중간 추가, 삭제, 변경
		splice(start, deleteCount, ...items)  
			=> start 에서부터 deleteCount만큼 제거하고 items 들을 그자리에 추가


	const fruits2 = ["Apple", "Orange", "Melon"];
	fruits2
	(3) ['Apple', 'Orange', 'Melon']
	ftruits2.push("Mango", "Aaa");
	fruits2.push("Mango", "Aaa");
	5
	const removed = fruits2.pop(); //꺼내옴
	removed;
	'Aaa'	
	
7) 배열 요소가 있는지 확인하기

2. 배열의 메서드
1) Array.prototype의 메서드 목록
	Symbol.iterator 가 정의된 경우 
		for .. of 구문 


3. 다차원 배열
4. 유사배열
	 상속관계가(프로토타입 체인)이 Array.prototype이 아닌 형태 
	 
5. Array.prototype의 메서드를 유사 배열 객체에서 사용하기
	 
	 
	 
ECMAScript6+에 추가된 기능
1. 비구조화 할당
1) 배열의 비구조화 할당
- 기본적인 사용법
const|let [a, b] = [1, 2];
	a = 1
	b = 2
- 이미 선언된 변수를 비구조화 할당하는 예
- 나머지 요소
	... 
	
	참고)
		이터레이터, 제너레이터 -> 값을 전개
		
- 요소의 기본값
2) 객체의 비구조화 할당
- 기본적인 사용법
- 프로터피의 기본값
- 프로퍼티 이름 생략하기
3) 반복 가능한 객체의 비구조화 할당
- 이터레이터, 제너레이터 
4) 중첩된 자료 구조의 비구조화 할당


2. 전개 연산자

3. Map
1) Map 객체의 생성
2) Map 객체의 메서드
3) 데이터 추가하기
	set("키", "값")
	
4) 값 읽기
	get(키)
	
5) 데이터가 있는지 확인
	has(키)
	
6) 데이터의 삭제
	delete("키")
	
7) 데이터의 열거
	keys() : 키값의 배열 목록
	values() : 값의 배열 목록 

8) entries() : 키,값 쌍 목록 

4. Set
1) Set 객체의 생성
2) Set 객체의 메서드
3) 데이터 추가
	add(...)
4) 데이터가 있는지 확인
	has(...)
5) 데이터의 삭제
	delete(...)
6) 데이터의 열거
	.forEach(....)
	
	
	keys(), values() : 동일 값 