생성자

객체=변수+함수

prototype 

new 연산자로 객체 만드는 것은 다음 과정과 동일하다

1) 함수 객체의 prototype 객체의 상속 (상속은 자원을 공유하려는 목적)
2) this가 prototype객체를 상속받은 객체로 주소변경 -> 초기화

function Person() {
    this.name = "최지예";
    this.age = 25;
};
console.dir(Person);
const p1 = {};
p1.__proto__ = Person.prototype;
Person.apply(p1);  == Person.prototype.constructor.apply(p1);   -> 초기화
p1;
Person {name: '최지예', age: 25}


함수내의 매서드 정의는 prototype에 정의하는게 상속 시 같은 기능을 중복되게 자원관리하지 않도록할 수 있다.
상속을 총해 공유하게 하기 위함.

예1) 바람직 하지 않은 함수내의 매서드 정의
function Person(name, age) {
    this.name = name;
    this.age = age;
	this.showInfo = function () {
		console.log(this.name, this.age);
	}
};

const p1 = new Person('김이름', 30);
const p2 = new Person('이이름', 50);
p1.showInfo === p2.showInfo;
  => false

예2) 상속을 위한 올바른 메서드 정의
function Person(name, age) {
    this.name = name;
    this.age = age;
};
Person.prototype.showInfo = function() {
    console.log(this.name, this.age);
};

const p1 = new Person('김이름', 30);
const p2 = new Person('이이름', 50);
p1.showInfo === p2.showInfo;
  => true

===== 새로운 구문 ========================
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    showInfo(){
        console.log(this.name, this.age);
    }
}

class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    static count  = 10;
    static staticMethod() {
        console.log('정적 메소드..');
    }
    showInfo(){
        console.log(this.name, this.age);
    }
}
const p1 = new Person('이이름', 40);
console.dir(p1.showInfo);  ==> prototype 이 없으므로 ..생성자로 사용은 안된다(상속은 안된다)


===================================
function Elipse(a, b) {
    this.a = a;
    this.b = b;
}
Elipse.prototype.area = function() {
    console.log('면적: ' + this.a * this.b * Math.PI);
}
function Circle(r) {
    this.a = r;
    this.b = r;
}
Circle.prototype.__proto__ = Elipse.prototype;
Circle.prototype.constructor = Circle;

const c1 = new Circle(10);
c1.area();


===================================
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    showInfo(){
        console.log(this.name, this.age);
    }
}

======>
요렇게 쓰자 간단히 

class Elipse {
    constructor(a, b) {
        this.a = a;
        this.b = b;
    }
    area() {
        console.log('면적 :' ,  this.a * this.b * Math.PI);
    }
}
class Circle extends Elipse {
    constructor(r) {
        super(r, r);
    }
}

const c1 = new Circle(10);
c1.area();

---------------------------
이렇게 함수를 정의하기도 한다 

const add = (a,b) => a + b;
add instanceof Function;
-> true
console.log(dir(add));
typeof add;
-> 'function'
console.dir(add);
---------------------------


생성자 함수 객체의 상속


new 생성자 함수(); 
	1) prototype 객체의 상속 ( prototype에 정의된 자원 공유 )
	2) this값 -> 현재 생성될 객체의 주소 -> 생성자함수 호출 -> 초기화

 연산자
	instanceof : 객체의 출처를 체크(프로토타입 체인)
		function Person() {
		this.name = '최지수';
		this.age = 40;
	}
	const p1 = new Person();
	p1 instanceof Person;  <- p1은 Person에서 생성된 객체인지 확인
	-> true
	Person instanceof Function ;
	-> true
	p1 instanceof Object;
	-> true
	p1 instanceof Array;
	-> false	
	

자바스크립트객체

코어객체
	- 내장 생성자 함수 객체
	
	- 내장객체
		Math - 수학관련 편의 메서드가 있는 객체
		JSON 
	
호스트객체 : 실행환경에 따른 객체
	- 웹브라우저 객체 - 웹브라우저의 기능과 관련된 객제
	   window
	     location 객체 - 브라우저의 주소와 관연된 기능, 정보
		 history 객체 - 브라우저의 방문기록과 기능
		 screen 객체
		 navigator 객체
		 
		 document 객체 - 웹문서를 다루는 객체
		 


